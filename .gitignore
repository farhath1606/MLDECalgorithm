import tkinter as tk
from tkinter import messagebox, scrolledtext
import secrets
import base64
import hashlib
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes

# --- MLDEC Core Functions ---

def pad(data):
    pad_len = 16 - (len(data) % 16)
    return data + bytes([pad_len] * pad_len)

def unpad(data):
    pad_len = data[-1]
    return data[:-pad_len]

def sha256_key(passphrase):
    return hashlib.sha256(passphrase.encode()).digest()

def caesar_shift(data, key, encrypt=True):
    shift = sum(key) % 256
    return bytes([(b + shift) % 256 if encrypt else (b - shift) % 256 for b in data])

def xor_keystream(data, key):
    keystream = hashlib.sha256(key).digest()
    return bytes([b ^ keystream[i % len(keystream)] for i, b in enumerate(data)])

def matrix_transpose(data, encrypt=True):
    length = len(data)
    import math
    size = int(math.ceil(length**0.5))
    if encrypt:
        out = bytearray(length)
        idx = 0
        for col in range(size):
            for row in range(size):
                pos = row * size + col
                if pos < length:
                    out[idx] = data[pos]
                    idx += 1
        return bytes(out)
    else:
        out = [0]*length
        idx = 0
        for col in range(size):
            for row in range(size):
                pos = row * size + col
                if pos < length:
                    out[pos] = data[idx]
                    idx += 1
                    if idx == length:
                        return bytes(out)
        return bytes(out)

# --- AES S-Box (forward & inverse) ---

SBOX = bytes([
    0x63,0x7C,0x77,0x7B,0xF2,0x6B,0x6F,0xC5,0x30,0x01,0x67,0x2B,0xFE,0xD7,0xAB,0x76,
    0xCA,0x82,0xC9,0x7D,0xFA,0x59,0x47,0xF0,0xAD,0xD4,0xA2,0xAF,0x9C,0xA4,0x72,0xC0,
    0xB7,0xFD,0x93,0x26,0x36,0x3F,0xF7,0xCC,0x34,0xA5,0xE5,0xF1,0x71,0xD8,0x31,0x15,
    0x04,0xC7,0x23,0xC3,0x18,0x96,0x05,0x9A,0x07,0x12,0x80,0xE2,0xEB,0x27,0xB2,0x75,
    0x09,0x83,0x2C,0x1A,0x1B,0x6E,0x5A,0xA0,0x52,0x3B,0xD6,0xB3,0x29,0xE3,0x2F,0x84,
    0x53,0xD1,0x00,0xED,0x20,0xFC,0xB1,0x5B,0x6A,0xCB,0xBE,0x39,0x4A,0x4C,0x58,0xCF,
    0xD0,0xEF,0xAA,0xFB,0x43,0x4D,0x33,0x85,0x45,0xF9,0x02,0x7F,0x50,0x3C,0x9F,0xA8,
    0x51,0xA3,0x40,0x8F,0x92,0x9D,0x38,0xF5,0xBC,0xB6,0xDA,0x21,0x10,0xFF,0xF3,0xD2,
    0xCD,0x0C,0x13,0xEC,0x5F,0x97,0x44,0x17,0xC4,0xA7,0x7E,0x3D,0x64,0x5D,0x19,0x73,
    0x60,0x81,0x4F,0xDC,0x22,0x2A,0x90,0x88,0x46,0xEE,0xB8,0x14,0xDE,0x5E,0x0B,0xDB,
    0xE0,0x32,0x3A,0x0A,0x49,0x06,0x24,0x5C,0xC2,0xD3,0xAC,0x62,0x91,0x95,0xE4,0x79,
    0xE7,0xC8,0x37,0x6D,0x8D,0xD5,0x4E,0xA9,0x6C,0x56,0xF4,0xEA,0x65,0x7A,0xAE,0x08,
    0xBA,0x78,0x25,0x2E,0x1C,0xA6,0xB4,0xC6,0xE8,0xDD,0x74,0x1F,0x4B,0xBD,0x8B,0x8A,
    0x70,0x3E,0xB5,0x66,0x48,0x03,0xF6,0x0E,0x61,0x35,0x57,0xB9,0x86,0xC1,0x1D,0x9E,
    0xE1,0xF8,0x98,0x11,0x69,0xD9,0x8E,0x94,0x9B,0x1E,0x87,0xE9,0xCE,0x55,0x28,0xDF,
    0x8C,0xA1,0x89,0x0D,0xBF,0xE6,0x42,0x68,0x41,0x99,0x2D,0x0F,0xB0,0x54,0xBB,0x16
])
INV_SBOX = bytes([SBOX.index(i) for i in range(256)])

def sbox_substitute(data, encrypt=True):
    box = SBOX if encrypt else INV_SBOX
    return bytes([box[b] for b in data])

def aes_encrypt(data, key):
    iv = get_random_bytes(16)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    return iv + cipher.encrypt(data)

def aes_decrypt(data, key):
    iv = data[:16]
    cipher = AES.new(key, AES.MODE_CBC, iv)
    return cipher.decrypt(data[16:])

def encrypt_mldec(plaintext, passphrase):
    key = sha256_key(passphrase)
    data = plaintext.encode()
    data = caesar_shift(data, key, encrypt=True)
    data = xor_keystream(data, key)
    data = sbox_substitute(data, encrypt=True)
    data = pad(data)
    data = matrix_transpose(data, encrypt=True)
    data = aes_encrypt(data, key)
    return base64.b64encode(data).decode()

def decrypt_mldec(ciphertext_b64, passphrase):
    try:
        key = sha256_key(passphrase)
        enc = base64.b64decode(ciphertext_b64)
        data = aes_decrypt(enc, key)
        data = matrix_transpose(data, encrypt=False)
        data = unpad(data)
        data = sbox_substitute(data, encrypt=False)
        data = xor_keystream(data, key)
        data = caesar_shift(data, key, encrypt=False)
        return data.decode(errors="ignore")
    except Exception as e:
        return "Error: " + str(e)

def generate_random_key(length=8):
    return secrets.token_hex(length)

# --------------------------- GUI SETUP ---------------------------

root = tk.Tk()
root.title("Cryptography Algorithm")
root.geometry("900x600")
root.resizable(True, True)
root.configure(bg="#121212")

accent = "#00ffff"
label_font = ("Consolas", 12, "bold")
text_font = ("Consolas", 11)

header = tk.Label(root, text="Cryptography Algorithm", bg="#121212", fg=accent, font=("Consolas", 18, "bold"))
header.pack(pady=(10,5))

key_frame = tk.Frame(root, bg="#1e1e1e", padx=10, pady=8, bd=4, relief=tk.RIDGE)
key_frame.pack(fill="x", padx=20, pady=5)
tk.Label(key_frame, text="Key:", font=label_font, bg="#1e1e1e", fg="white").pack(side=tk.LEFT)
key_entry = tk.Entry(key_frame, width=40, font=text_font, bg="#2c2c2c", fg=accent, insertbackground=accent)
key_entry.pack(side=tk.LEFT, padx=10)
tk.Button(key_frame, text="Generate Key", command=lambda: (
    key_entry.delete(0, tk.END),
    key_entry.insert(0, generate_random_key())
), bg="#2c2c2c", fg=accent, bd=4, relief=tk.RAISED).pack(side=tk.LEFT)

center = tk.Frame(root, bg="#121212")
center.pack(fill="both", expand=True, padx=20, pady=10)

left = tk.Frame(center, bg="#121212")
left.pack(side=tk.LEFT, fill="both", expand=True)
tk.Label(left, text="Input (Plain/Cipher):", font=label_font, bg="#121212", fg="white").pack(anchor="w")
input_text = scrolledtext.ScrolledText(left, font=text_font, bg="#1e1e1e", fg=accent, insertbackground=accent, wrap=tk.WORD)
input_text.pack(fill="both", expand=True, padx=(0,10))

right = tk.Frame(center, bg="#121212")
right.pack(side=tk.LEFT, fill="both", expand=True)
tk.Label(right, text="Output:", font=label_font, bg="#121212", fg="white").pack(anchor="w")
output_text = scrolledtext.ScrolledText(right, font=text_font, bg="#1e1e1e", fg=accent, insertbackground=accent, wrap=tk.WORD)
output_text.pack(fill="both", expand=True, padx=(10,0))

btn_frame = tk.Frame(root, bg="#121212")
btn_frame.pack(pady=8)
tk.Button(btn_frame, text="Encrypt", command=lambda: (
    output_text.delete("1.0",tk.END),
    output_text.insert(tk.END, encrypt_mldec(input_text.get("1.0",tk.END).strip(), key_entry.get().strip()))
), width=15, bg="#2c2c2c", fg=accent, bd=5, relief=tk.RAISED, font=("Consolas",12,"bold")).pack(side=tk.LEFT, padx=20)

tk.Button(btn_frame, text="Decrypt", command=lambda: (
    output_text.delete("1.0",tk.END),
    output_text.insert(tk.END, decrypt_mldec(input_text.get("1.0",tk.END).strip(), key_entry.get().strip()))
), width=15, bg="#2c2c2c", fg=accent, bd=5, relief=tk.RAISED, font=("Consolas",12,"bold")).pack(side=tk.LEFT, padx=20)

footer = tk.Label(root,
    text="Developed for Cybersecurity Project\nMade by: Ali Isam Husam\nMhantharan Loganathan\nNur Farhath BintiÂ Safiullah",
    bg="#121212", fg="white", font=("Consolas",10), justify="center")
footer.pack(pady=5)

root.mainloop()
